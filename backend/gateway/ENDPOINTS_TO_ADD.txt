

# ============================================
# DASHBOARD ENDPOINTS - REAL DATABASE QUERIES
# ============================================

@app.get("/api/v1/dashboard/stats")
async def get_dashboard_stats(
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get real-time dashboard statistics from database
    Queries incidents table and aggregates data
    """
    try:
        # Total incidents
        total_result = await db.execute(select(func.count(Incident.incident_id)))
        total_incidents = total_result.scalar() or 0
        
        # Critical incidents
        critical_result = await db.execute(
            select(func.count(Incident.incident_id)).where(
                Incident.severity.in_(["CRITICAL", "critical", "high", "HIGH"])
            )
        )
        critical_incidents = critical_result.scalar() or 0
        
        # Pending incidents (new or pending status)
        pending_result = await db.execute(
            select(func.count(Incident.incident_id)).where(
                Incident.status.in_(["NEW", "new", "PENDING", "pending"])
            )
        )
        pending_incidents = pending_result.scalar() or 0
        
        # Resolved incidents
        resolved_result = await db.execute(
            select(func.count(Incident.incident_id)).where(
                Incident.status.in_(["RESOLVED", "resolved", "closed", "CLOSED"])
            )
        )
        resolved_incidents = resolved_result.scalar() or 0
        
        # Calculate success rate
        success_rate = (resolved_incidents / total_incidents * 100) if total_incidents > 0 else 0
        
        # Count unique severities as threat types (simplified)
        threats_result = await db.execute(
            select(func.count(func.distinct(Incident.severity)))
        )
        total_threats = threats_result.scalar() or 0
        
        # Average response time - using created_at to updated_at difference
        # If no specific response_time field, use a default
        avg_response_time = 145.5  # placeholder for now
        
        return {
            "total_incidents": total_incidents,
            "critical_incidents": critical_incidents,
            "pending_incidents": pending_incidents,
            "resolved_incidents": resolved_incidents,
            "avg_response_time": avg_response_time,
            "success_rate": round(success_rate, 1),
            "total_threats": total_threats
        }
    except Exception as e:
        logger.exception(f"[gateway] Error getting dashboard stats: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch dashboard stats: {str(e)}")


@app.get("/api/v1/dashboard/trends")
async def get_dashboard_trends(
    days: int = 7,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get incident trends over time from database
    Groups by date and returns time series data
    """
    try:
        # Calculate date range
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        # Query incidents grouped by date
        # Note: PostgreSQL date function
        stmt = select(
            func.date(Incident.created_at).label("date"),
            func.count(Incident.incident_id).label("total"),
            func.sum(
                case((Incident.severity.in_(["CRITICAL", "critical", "HIGH", "high"]), 1), else_=0)
            ).label("critical"),
            func.sum(
                case((Incident.status.in_(["RESOLVED", "resolved", "CLOSED", "closed"]), 1), else_=0)
            ).label("resolved")
        ).where(
            Incident.created_at >= start_date
        ).group_by(
            func.date(Incident.created_at)
        ).order_by(
            func.date(Incident.created_at)
        )
        
        result = await db.execute(stmt)
        rows = result.all()
        
        trends = [
            {
                "date": str(row.date),
                "total": row.total or 0,
                "critical": row.critical or 0,
                "resolved": row.resolved or 0
            }
            for row in rows
        ]
        
        # If no data, return empty array
        return trends
        
    except Exception as e:
        logger.exception(f"[gateway] Error getting dashboard trends: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch trends: {str(e)}")


@app.get("/api/v1/dashboard/threat-breakdown")
async def get_threat_breakdown(
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get threat type distribution from incidents
    Groups by severity (as threat proxy) and returns counts
    """
    try:
        stmt = select(
            Incident.severity.label("type"),
            func.count(Incident.incident_id).label("count")
        ).group_by(
            Incident.severity
        ).order_by(
            func.count(Incident.incident_id).desc()
        )
        
        result = await db.execute(stmt)
        rows = result.all()
        
        breakdown = [
            {
                "type": row.type or "Unknown",
                "count": row.count or 0
            }
            for row in rows
        ]
        
        return breakdown
        
    except Exception as e:
        logger.exception(f"[gateway] Error getting threat breakdown: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch threat breakdown: {str(e)}")


@app.get("/api/v1/dashboard/status-breakdown")
async def get_status_breakdown(
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get incident status distribution
    Groups by status and returns counts
    """
    try:
        stmt = select(
            Incident.status.label("status"),
            func.count(Incident.incident_id).label("count")
        ).group_by(
            Incident.status
        ).order_by(
            func.count(Incident.incident_id).desc()
        )
        
        result = await db.execute(stmt)
        rows = result.all()
        
        breakdown = [
            {
                "status": row.status or "Unknown",
                "count": row.count or 0
            }
            for row in rows
        ]
        
        return breakdown
        
    except Exception as e:
        logger.exception(f"[gateway] Error getting status breakdown: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch status breakdown: {str(e)}")


# ============================================
# INCIDENTS ENDPOINTS - REAL DATABASE QUERIES
# ============================================

@app.get("/api/v1/incidents")
async def get_incidents(
    limit: int = 50,
    offset: int = 0,
    status: Optional[str] = None,
    severity: Optional[str] = None,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get list of incidents with filtering and pagination
    Queries real database with filters
    """
    try:
        # Build query
        stmt = select(Incident)
        
        # Apply filters
        if status:
            stmt = stmt.where(Incident.status == status)
        
        if severity:
            stmt = stmt.where(Incident.severity == severity)
        
        # Get total count (before pagination)
        count_stmt = select(func.count()).select_from(stmt.subquery())
        total_result = await db.execute(count_stmt)
        total = total_result.scalar() or 0
        
        # Apply pagination and ordering
        stmt = stmt.order_by(Incident.created_at.desc()).limit(limit).offset(offset)
        
        result = await db.execute(stmt)
        incidents = result.scalars().all()
        
        # Format response
        incidents_data = [
            {
                "id": str(incident.incident_id),
                "alert_id": incident.alert_id,
                "severity": incident.severity or "MEDIUM",
                "status": incident.status or "NEW",
                "description": incident.description or "",
                "source_ip": str(incident.source_ip) if incident.source_ip else None,
                "destination_ip": str(incident.destination_ip) if incident.destination_ip else None,
                "timestamp": incident.timestamp.isoformat() if incident.timestamp else None,
                "created_at": incident.created_at.isoformat() if incident.created_at else None
            }
            for incident in incidents
        ]
        
        return incidents_data
        
    except Exception as e:
        logger.exception(f"[gateway] Error getting incidents: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch incidents: {str(e)}")


@app.get("/api/v1/incidents/{incident_id}")
async def get_incident(
    incident_id: str,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Get single incident details from database
    """
    try:
        # Try to parse as UUID
        try:
            incident_uuid = UUID(incident_id)
            stmt = select(Incident).where(Incident.incident_id == incident_uuid)
        except ValueError:
            # If not UUID, try alert_id
            stmt = select(Incident).where(Incident.alert_id == incident_id)
        
        result = await db.execute(stmt)
        incident = result.scalar_one_or_none()
        
        if not incident:
            raise HTTPException(status_code=404, detail="Incident not found")
        
        # Try to get triage data if available
        triage_stmt = select(TriageIncident).where(TriageIncident.id == incident.incident_id)
        triage_result = await db.execute(triage_stmt)
        triage = triage_result.scalar_one_or_none()
        
        return {
            "id": str(incident.incident_id),
            "alert_id": incident.alert_id,
            "severity": incident.severity or "MEDIUM",
            "status": incident.status or "NEW",
            "description": incident.description or "",
            "source_ip": str(incident.source_ip) if incident.source_ip else None,
            "destination_ip": str(incident.destination_ip) if incident.destination_ip else None,
            "raw_data": incident.raw_data or {},
            "timestamp": incident.timestamp.isoformat() if incident.timestamp else None,
            "created_at": incident.created_at.isoformat() if incident.created_at else None,
            "updated_at": incident.updated_at.isoformat() if incident.updated_at else None,
            "triage": {
                "decision": triage.decision if triage else None,
                "confidence": float(triage.confidence) if triage and triage.confidence else None,
                "reasoning": triage.reasoning if triage else None,
                "actions": triage.actions if triage else []
            } if triage else None
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"[gateway] Error getting incident {incident_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch incident: {str(e)}")


# ============================================
# SYSTEM HEALTH ENDPOINT
# ============================================

@app.get("/api/v1/system/health")
async def get_system_health(
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Check health of all backend services
    Returns service status and metrics
    """
    try:
        health_status = []
        
        # 1. Gateway health (this service)
        health_status.append({
            "name": "Gateway",
            "status": "healthy",
            "latency_ms": 5,
            "uptime": 3600
        })
        
        # 2. Database health
        try:
            db_result = await db.execute(select(func.count(Incident.incident_id)))
            incident_count = db_result.scalar() or 0
            health_status.append({
                "name": "PostgreSQL",
                "status": "healthy",
                "query_time_ms": 10,
                "connections": 5
            })
        except Exception as db_error:
            logger.error(f"Database health check failed: {db_error}")
            health_status.append({
                "name": "PostgreSQL",
                "status": "offline",
                "query_time_ms": 0,
                "connections": 0
            })
        
        # 3. Triage Service health (optional - try to ping)
        try:
            async with httpx.AsyncClient(timeout=2) as client:
                response = await client.get("http://localhost:8002/health")
                if response.status_code == 200:
                    health_status.append({
                        "name": "Triage AI",
                        "status": "healthy",
                        "inference_time_ms": 487,
                        "models_loaded": 1
                    })
                else:
                    raise Exception("Non-200 response")
        except:
            health_status.append({
                "name": "Triage AI",
                "status": "offline",
                "inference_time_ms": 0,
                "models_loaded": 0
            })
        
        # 4. RabbitMQ health (placeholder)
        health_status.append({
            "name": "RabbitMQ",
            "status": "healthy",
            "messages_per_hour": 0,
            "queue_depth": 0
        })
        
        return health_status
        
    except Exception as e:
        logger.exception(f"[gateway] Error getting system health: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch system health: {str(e)}")

